#!/usr/bin/env python3

"""A script to interact with your Google Drive files using the terminal"""

import pickle
import os.path
import io
import sys
import mimetypes
import threading
import time
import getopt
from os.path import expanduser
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload

CHUNK_SIZE = 1024 * 1024 # 1MB
HOME = expanduser("~")
GDRIVE_PATH = HOME + '/.gdrive/'
CREDENTIALS_PATH = GDRIVE_PATH + 'credentials.json'
TOKEN_PATH = GDRIVE_PATH + 'token.pickle'

# If modifying these scopes, delete the file token.pickle.
SCOPES = [
    'https://www.googleapis.com/auth/drive',
    'https://www.googleapis.com/auth/drive.metadata'
]

functions = ['download', 'upload', 'list']

def init():
    """Shows basic usage of the Drive v3 API.
    Prints the names and ids of the first 10 files the user has access to.
    """
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists(TOKEN_PATH):
        with open(TOKEN_PATH, 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                CREDENTIALS_PATH, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
    service = build('drive', 'v3', credentials=creds)
    return service

def get_filename(service, file_id):
    """Gets the file name for a file ID"""
    filename = 'gdrive-file'
    try:
        file_metadata = service.files().get(fileId=file_id, fields='name').execute()
        filename = file_metadata['name']
    except Exception as err:
        print('An error happened while getting file name.')
        print(err)

    print('Filename is "%s" for ID: %s.' % (filename, file_id))
    return filename

def size_to_human_readable(num, suffix='B'):
    """Converts bytes to a more human-readable metric"""
    for unit in ['', 'K', 'M', 'G', 'T']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0

def search_filename(service, file_name=None, page_size=10, list_all=False, page_token=None):
    """Search for a file by filename in the Google Drive"""
    query = ''
    if file_name and not list_all:
        # Could also be name = '%s' for an exact search
        query = "name contains '%s'" % file_name
    if page_token is None:
        page_token = ''
    fields = 'nextPageToken, files/id, files/name, files/size, files/modifiedTime, files/owners'
    search = service.files().list(q=query,
                                  orderBy='modifiedTime desc',
                                  fields=fields,
                                  pageSize=page_size,
                                  pageToken=page_token).execute()
    return search.get('files', []), search.get('nextPageToken', None)

def list_files(service, file_name, list_all=False):
    """List files present on user's Google Drive"""
    files, next_page = search_filename(service, file_name, 10, list_all)
    for file in files:
        describe_file(file)
    while next_page is not None:
        if input(">>> Press Enter for the next results\n"):
            break
        files, next_page = search_filename(service, file_name, 10, next_page)
        for file in files:
            describe_file(file)

def describe_file(file):
    """Print file metadata"""
    print("Name: %s" % file["name"])
    if 'size' in file:
        print("Size: %s" % size_to_human_readable(float(file["size"])))
    print("Modified: %s" % file["modifiedTime"])
    print("Owner: %s" % file["owners"][0]["displayName"])
    print("ID: %s\n" % file["id"])

def download_name(service, file_name):
    """Download a file by name"""
    if file_name is None:
        print('Please inform the name of the file you want to download. Exiting...')
        return
    file_found, _ = search_filename(service, file_name, 1)
    if not file_found:
        return print("Could not find any file with the name '%s'" % file_name)
    describe_file(file_found[0])
    download(service, file_found[0]["id"])

def download(service, file_id):
    """Download a file by file ID"""
    if file_id is None:
        print('Please inform the ID of the file you want to download. Exiting...')
        return

    filename = get_filename(service, file_id)

    try:
        request = service.files().get_media(fileId=file_id)

        file_handler = io.FileIO(filename, 'wb')
        downloader = MediaIoBaseDownload(file_handler, request, chunksize=CHUNK_SIZE)

        done = False
        print("Downloading 0%", end='\r')
        logger = Logger("Downloading")
        while done is False:
            status, done = downloader.next_chunk()
            logger.send(status)
        logger.close()
        print("Downloaded 100% ")
    except Exception as err:
        print('An error happened while downloading the file.')
        print(err)

def upload(service, filepath):
    """Upload a file"""
    guessed_type = mimetypes.guess_type(filepath, True)
    if guessed_type is None:
        print('Wasn`t able to guess mimetype.')
        return
    mime_type = guessed_type[0]

    filename = filepath.split('/')[-1]
    print('Uploading the file: %s' % filename)

    try:
        file_metadata = {'name': filename}
        media = MediaFileUpload(filepath,
                                mimetype=mime_type,
                                resumable=True,
                                chunksize=CHUNK_SIZE)
        created_file = service.files().create(body=file_metadata,
                                              media_body=media,
                                              fields='id')
        response = None
        print("Uploading 0%", end='\r')
        logger = Logger("Uploading")
        while response is None:
            status, response = created_file.next_chunk()
            if status:
                logger.send(status)
        logger.close()
        print("Uploaded 100% ")
        print('File ID: %s\n' % response.get('id'))
    except Exception as err:
        print('An error occurred while uploading the file.')
        print(err)

def read_argv():
    """Read arguments"""
    list_all = file_id = file_name = None
    try:
        opts, _ = getopt.getopt(sys.argv[2:], "han:i::", ["help", "all", "name=", "id="])
    except getopt.GetoptError:
        print_help()
    for opt, value in opts:
        if opt in ("-h", "--help"):
            print_help()
        if opt in ("-a", "--all"):
            list_all = True
        elif opt in ("-i", "--id"):
            file_id = value
        elif opt in ("-n", "--name"):
            file_name = value
        else:
            assert False, "unhandled option"
    return {'file_id': file_id, 'file_name': file_name, 'list_all': list_all}

def print_help():
    """Print help"""
    print("Download examples:")
    print("\tdownload some_file.gz")
    print("\tdownload --name some_file.gz")
    print("\tdownload -n some_file.gz")
    print("\tdownload --id abcde123456")
    print("\tdownload -i abcde123456")
    print("\nUpload examples:")
    print("\tupload some_file.gz")
    print("\nList examples:")
    print("\tlist some_file")
    print("\tlist --all")
    print("\tlist -a")
    sys.exit()

def main():
    """Main function. Entry point for the script"""
    args_size = len(sys.argv)
    if args_size < 3:
        print_help()
        return

    func = sys.argv[1]
    if func not in functions:
        print('This function is not implemented yet.')
        print_help()
        return

    service = init()
    if service is None:
        print('Failed to start service. Exiting..')
        return

    opt = read_argv()
    # If there is an ID, downloads with that ID
    # If there is a name, downloads with that name
    # If there is nothing, downloads with the third argument
    if func == 'download':
        if opt['file_id']:
            download(service, opt['file_id'])
        else:
            if not opt['file_name']:
                opt['file_name'] = sys.argv[2]
            download_name(service, opt['file_name'])
    elif func == 'upload':
        upload(service, sys.argv[2])
    elif func == 'list':
        list_files(service, sys.argv[2], opt['list_all'])


class ConflatedChannel:
    """A list of size 0 or 1. When adding to a list of size=1, substitute the value"""
    def __init__(self):
        """Initialize channel"""
        self.__channel = []
        self.__open = True

    def __str__(self):
        """String representation"""
        return str(self.__channel)

    def send(self, value):
        """Adds to the channel. If full, replace value.
        If channel is closed, raise a ValueError.
        """
        if not self.is_open():
            raise ValueError("Channel is closed.")

        self.__channel.clear()
        self.__channel.append(value)

    def pop(self):
        """Returns the value in the channel, or None"""
        try:
            return self.__channel.pop()
        except:
            return None

    def is_open(self):
        """Checks if the channel is open for send()"""
        return self.__open

    def close(self):
        """Close the channel. It will not receive new values."""
        self.__open = False

class Logger():
    """Logs progress from a worker thread."""
    def __init__(self, operation):
        self.__channel = ConflatedChannel()
        self.__operation = operation
        self.__start_time = time.time()
        self.__worker = threading.Thread(target=self.__work, daemon=True)
        self.__worker.start()

    def send(self, status):
        """Try to send a new value to the channel."""
        self.__channel.send(status)

    def close(self):
        """Close the channel and join the thread."""
        self.__channel.close()
        self.__worker.join()

    def __work(self):
        """Print logs while the channel is open and receiving values."""
        last_size = 0.0
        last_time = self.__start_time
        while self.__channel.is_open():
            status = self.__channel.pop()
            if status:
                new_time = time.time()
                self.__log_progress(status, last_size, last_time)
                last_time = new_time
                last_size = status.resumable_progress
            # Limits logs to 1 per second at most
            time.sleep(1)

    def __log_progress(self, status, previous_size, previous_time):
        """Print log from status."""
        progress = int(status.progress() * 100)
        total_size = size_to_human_readable(status.total_size)
        current_size = status.resumable_progress
        size = size_to_human_readable(current_size)

        current_time = time.time()
        timer = time.strftime("%H:%M:%S", time.gmtime(current_time - self.__start_time))

        diff_size = current_size - previous_size
        diff_time = current_time - previous_time
        bps = diff_size / diff_time
        speed = size_to_human_readable(bps)

        estimated_time = (status.total_size - current_size) / bps
        eta = time.strftime("%H:%M:%S", time.gmtime(estimated_time))

        print("%s %d%% - %s/%s - %s/s - %s - ETA: %s             " %
              (self.__operation, progress, size, total_size, speed, timer, eta), end='\r')

if __name__ == '__main__':
    main()
